# Выравнивание
Рассмотрим следующий пример: 
```c++
#include <vector>
#include <iostream>

#pragma pack(push, 1)
struct Foo {
    std::vector<int> v;
};
#pragma pack(pop)

int main() {
    Foo f;
    std::cout << alignof(f) << "\n";
    std::cout << alignof(std::vector<int>) << "\n";
}
```
Получим 1 и 8 соответственно, то есть `pragma`s life matter даже если у нас одно поле. Это может привести к неприятным вещам, например, если `Foo` имеет вид:
```c++
struct Foo {
    char x;
    std::vector<int> v;
}
```
Получаем невыровненный вектор по адресу, потому что вся структура выровнена по 16 байт, а вектор съехал на 1 байт. А оно вам нужно? Учитывая, что некоторые процессоры не умеют в невыровненный доступ

# Placement new
Рассмотрим такую штуку:
```c++
char data[100] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
std::vector<char> *v = new (data) std::vector<char>(100);
std::cout << v->size() << "\n";
std::cout << static_cast<int>((*v)[0]) << "\n";
```
Выведется 100, 0. Почему? Уж так на Руси повелось, что `placement new` берет кусок памяти, в нём создает переменную определённого типа (в случае вектора создается 3 указателя: на начало, конец и `capacity`). Дальше вектор в своем конструкторе выделяет памяти под сколько-то байт и заполняет дефолтными значениями. То есть преобразовывать массив в вектор с помощью `placement new` - затея так себе.

# Исключения 
Начнем с классификации, от std::exception наследуются `std::logic_error` - это те ляпы, которые можно найти до запуска программы и `std::runtime_error` - ошибки, возникающие при вводе пользователя.
Далее чекаем пример:
```c++
struct my_error_1 : std::exception {
    const char *what() const noexcept override {
        return "hello";  // ok
//        return std::to_string(10).c_str();  // UB, но прячется (из-за Small String Optimization?)
//        return std::string(100, 'a').c_str();  // UB, меньше прячется.
    }
};
```
У обычного `std::exception` беды с башкой: what возвращает `const char *`, поэтому нам норм при выводе строковых констант, но пример с `std::string` уже не работает. Дело в том, что в данном примере мы создаем строчку с помощью to_string, который динамически выделяет для себя память, записывает в ней строчку "10". После чего мы берем указатель на начало этой строчки. Однако `to_string` умирает после ";" и в момент `return` мы имеем указатель на сдохшую строчку, и это UB в момент вызова `what`.

Эту проблему можно было бы решить так:
```c++
struct my_error_2 : std::exception {
    char str[10] = "msg?";

    my_error_2(int x) {
        assert(0 <= x && x <= 9);
        str[3] = '0' + x;
    }

    const char *what() const noexcept override {
        return str;  // ok
    }
};
```
Или так, но тут появляются траблы с `operator=` (компиляторы могут копировать исключения):
```c++
struct my_error_3 : std::exception {
    std::string str;  // Oops: operator=() должен быть noexcept, но не может.

    my_error_3(int x) : str("hello " + std::to_string(x)) {
    }

    const char *what() const noexcept override {
        return str.c_str();  // ok
    }
};
```
Но лучше использовать `std::runtime_error` - он уже позаботился о конструкторе от `std::string` и о корректно переопределённом `what` 
```c++
struct my_error_4 : std::runtime_error {
    // Ok.
    my_error_4(int x) : std::runtime_error("hello " + std::to_string(x)) {
    }
};
```

### Чё по времени?
Бросить и обработать исключение - это очень дорого по времени. Причина кроется в склонности компиляторов к задумчивости при виде `throw`: они начинают в буквальном смысле перебирать стек и чекать, какие есть переменные и `catch`. При этом сами `try` и `catch` работают быстро.


### Плюсы noexcept 
Если можете добавить `noexcept` - добавьте, потому что:
* тот же вектор ведет себя по-разному, если его `move_operator` `noexcept` или нет из-за поддержки строгой гарантии
* `i++; my_noexcept; i++`  - этот код будет оптимизирован в i+=2, если функция noexcept
* с ним компилятору не нужно готовиться к раскрутке стека


### Замечания
Некоторые компании запрещают код с исключениями по следующим причинам:
* начали писать код в мезозойской эре без них, а переписывать его не хочется
* исключения не `zero-overhead` (то есть если у нас в коде есть `throw`, но вы им не пользуетесь, то многие оптимизации энивэй отрубаются)
* библиотека может их не поддерживать :(


### Делегирующие конструкторы

```c++
#include <stdexcept>
#include <iostream>

struct Foo {
    int x = 10;
    Foo(int) {
        std::cout << "Foo(int) a\n";
    }

    Foo(int, int) : Foo(10) {
        std::cout << "Foo(int, int) a\n";
        throw 0;
        std::cout << "Foo(int, int) b\n";
    }
    ~Foo() {
    std::cout << "~Foo()\n";
}
};

int main() {
    try {
        Foo f(10, 20);
    } catch (...) {
        std::cout << "exception\n";
    }
}
```

**Вывод:**  
Foo(int) a  
Foo(int, int) a  
~Foo()  
exception  

Связано сие с тем, что объект считается созданным, если выполнился хотя бы один конструктор. Конструкторы, делегирующие другие конструкторы, изменяют поля структуры, но не инициализируют их. А вот в этом примере:
```c++
#include <stdexcept>
#include <iostream>

struct Foo {
    int x = 10;
    Foo(int) {
        std::cout << "Foo(int) a\n";
    }

    Foo(int, int) {
        std::cout << "Foo(int, int) a\n";
        throw 0;
        std::cout << "Foo(int, int) b\n";
    }
    ~Foo() {
    std::cout << "~Foo()\n";
}
};

int main() {
    try {
        Foo f(10, 20);
    } catch (...) {
        std::cout << "exception\n";
    }
}
```
**Вывод:**  
Foo(int, int) a  
exception

Потому что объект не создан (в вызываемом конструкторе брошено исключение)

# C-arrays
Способы инициализации в `C`
```c++
int a1[10]; // заполнение мусором
int a2[10] = {};  // default-initialize всех элементов: 0.
int a3[10]{}; // directed-initialize всех элементов
int a4[10] = {1, 2, 3};  // default-initialize всех элементов (кроме первых, они copy-initialize): 0.
int a5[10]{1, 2, 3}; // directed-initialize первых трех, остальные default 
int a6[10] = { 0 };  // массив нулей.
int a7[10] = { 1 };  // 1 и 9 нулей.
```
`copy-initialize` для `implicit` конструкторов, `directed-initialize` - для всех.  
Есть ещё такие финты:
```c++
char c1[] = {1, 2, 3, 4};
char c2[] = "hello";  // Массив размера 6.
char c3[10] = "hello";  // Массив размера 10, проинициализированы первые 6 символов.

int *aptr = a1;
assert(aptr == &a1[0]);
assert(aptr + 1 == &a1[1]);
assert(aptr + 9 == &a1[9]);
aptr + 10;  // one-past-the-end, но нельзя разыменовать.
// &a1[10];  // UB - обращение к несуществующему элементу массива.
```
ещё есть `sizeof`, работающий на этапе компиляции, позволяет узнать размер чего угодно в байтах
```c++
 std::cout << sizeof(a1) << "\n";
 std::cout << sizeof(a1) / sizeof(a1[0]) << "\n"; //Аналог плюсового std::size  
```

### Передача массивов в функции
При передаче массива в функцию в `С` мы теряем данные о размере:
```c++
void foo(int arr[15]) {  // Заменяется на int *arr
    std::cout << arr[0] << "\n";
    std::cout << sizeof(arr) << "\n";
}
int arr[10]{1, 2, 3};
foo(arr);
```
Программа скомпилится и отработает  
**Вывод:**  
1  
8

Заметьте, что даже типы не проверились, но это не UB. Все потому, что `int arr[15]` в `C` заменяется на `int *arr`. В `C` ситуацию можно исправить так:
```c++
void foo_good(int arr[], int arr_len) {
    std::cout << arr[0] << " " << arr_len << "\n";
}
int arr[10]{1, 2, 3};
foo(arr);
```
**Вывод:**  
1  
10

а в `С++` так:
```c++
void foo_cpp_wtf(int (&arr)[10]) {  // C++-only, ok (компилятор С++ проверит типы)
// void foo_cpp_wtf(int (&arr)[5]) {  // C++-only, compilation error
// void foo_cpp_wtf(int (&arr)[15]) {  // C++-only, compilation error
}

template<std::size_t N> // N автоматически выводится по правилам вывода шаблонных параметров функции
void foo_cpp_templ(int (&arr)[N]) {
    std::cout << "N=" << N << "\n";
}
```

### C-strings
Наконец, вот как будет выглядеть `std::vector<std::string>>` в `C`. `NULL` в конце нужен для понимания размера массива. 
```c++
#include <cstring>
#include <iostream>

void print_all(const char **arr) {  // примерно vector<vector<char>>, только совсем руками.
    for (int i = 0; arr[i] != nullptr; i++) {
        std::cout << "i=" << i << ": ";
        for (int j = 0; arr[i][j] != 0; j++) {
            std::cout << arr[i][j];
        }
        std::cout << "\n";
    }
}

int main() {
    const char *arr[] = {
        "Hello123456",
        "World",
        nullptr  // NULL в языке Си.
    };
    print_all(arr);
}
```
**Вывод:**  
i=0: Hello123456  
i=1: World